<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 函数
    // function: 函数数据类型，相当于一个方法或者一个功能
    // 定义一个函数的步骤
    // 1. 开辟一个新的空间地址 xxxff111
    // 2. 把函数体中的js代码当做字符串存到空间里（一个函数只是定义了，并没有执行的话，这个函数没有任何意义）
    // 3. 再把我们的地址给函数名
    function fn() {
        // 函数体
        // 一个功能或者一个方式实现的步骤
        alert('前端真好~');
    }
    // 执行这个函数
    fn();
    // 首先会形成一个自己私有的地盘
    // 把定义的时候，存在空间的js代码字符串当做js代码执行

//    function 约会() {
//        1. 准备钱
//        2. 指定路线
//        3. 打电话约
//    }
//    约会();

    // 需求，计算和
    function sum() {
        var num = 1;
        num += 3;
        num *= 5;
        console.log(num);
    }
    sum();

    // js中，function的一个特别大的作用（函数的封装）：将实现一个功能的代码进行封装，以后如果用到了这个功能，代码没有必要再重新写了，
    // 只需要执行这个方法就好了

    // 第一次升级：形参（可以理解为一个变量）
    // 形参作用：实现一个功能，发现部分原材料没有，在制定计划的时候，我们没有办法获取，我们就把需要的原材料定义在我们的形参上，
    // 在执行的时候，把原材料提供了就好了。
    // 定义了形参，执行的时候没有传递值，那默认值是undefined
    function sum(num1, num2) {
        var total = 0;
        // 用typeof检查传递进来的形参是否传递正确
        if (typeof num1 !== 'undefined' && typeof num2 !== 'undefined') {
            total = num1 + num2;
        }
        console.log(total);
    }
    sum(1, 1); // 2
    sum(2, 2); // 4
    sum(1); // NaN, 1 + undefined = NaN

    // arguments: 是函数内置接受参数的机制
    // 内置：天生自带的，不管你是否传递了参数，也不管你是否写了形参，arguments一直存在
    // arguments也是一个类数组，它有数字作为索引，索引从0开始，代表第几个传递的参数；还有一个length的属性，
    // 代表传递了多少个参数
    // arguments获取其中的某一个元素，只能用arguments[索引]，不能用arguments.item(索引)
    // callee: arguments.callee代表的就是当前函数本身
    function fn() {
        console.dir(arguments);
        // console.dir()比console.log()在控制台输出的信息更详细一些
        console.log(arguments.length);
    }
    fn(1, 2, 3);

    // 任意数求和
    function fn() {
        var total = 0;
        for (var i = 0; i < arguments.length; i++) {
            var cur = arguments[i];
            cur = Number(cur);
            if (!isNaN(cur)) {
                total += cur;
            }
        }
        console.log(total);
    }
    console.log(1); // 1
    console.log(1, 2); // 3
    console.log(1, 2, 3); // 6

    // 函数执行的时候，会形成一个私有的地盘（这里面定义的变量，在外面不能直接使用）
    // 闭包：函数执行的时候会形成一个新的私有的作用域来保护里面的变量不受外界的干扰，这种保护机制叫做闭包
    // 外面想用什么，在函数里面直接的return返回就可以了，函数执行完成的整体就是这个值
    // 如果没有写return（或者只写了一个return;），则默认的返回结果undefined
    // 在函数体中，return后面的代码不再执行，可以利用这一点来控制函数体中的代码执行到指定位置就结束
    function fn() {
        var total = 0;
        for (var i = 0; i < arguments.length; i++) {
            var cur = arguments[i];
            cur = Number(cur);
            if (!isNaN(cur)) {
                total += cur;
            }
        }
        return total;
        total += 100; // 这里不再执行
    }
    console.log(fn(1, 2, 3));
    // 把函数执行完成的整体返回值赋值给外面的total变量
    var total = console.log(fn(1, 2, 3));
    console.log(total);

    // 以上的函数都称之为实名函数，还有一种函数叫做匿名函数
    // 匿名函数：
    // 1. 函数表达式：把一个匿名函数的定义部分当做一个值赋值给一个变量，或者一个元素的事件
    var fn = function () {

    }
    fn();
    var oBody = document.getElementsByTagName('body')[0];
    oBody.onclick = function () {

    }

    // 2. 自执行函数: 定义和执行一起完成的
    (function () {

    })();
    ~function () {

    }();
    !function () {

    }();
    +function () {

    }();
    -function () {

    }();
</script>
</body>
</html>