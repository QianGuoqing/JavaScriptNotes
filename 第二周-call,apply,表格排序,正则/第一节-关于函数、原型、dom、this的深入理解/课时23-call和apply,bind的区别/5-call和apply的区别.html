<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//    "use strict"; // -> 告诉当前浏览器接下来的JS代码将按照严格模式进行编写
    var obj = {name: 'zhufeng'};
    function fn(num1, num2) {
        console.log(num1 + num2);
        console.log(this);
    }
//    fn(100, 200); // this -> window num1 = 100 num2 = 200
//    fn.call(100, 200); // this -> 100 num1=200 num2=undefined -> NaN
//    fn.call(obj, 100, 200); // this -> obj num1=100 num2=200
//    fn.call(); // this -> window , 在严格模式下 this -> undefined
//    fn.call(null); // this -> window, 在严格模式下 this -> null
//    fn.call(undefined); // this -> window, 在严格模式下 this -> undefined

    // apply和call方法的作用是一模一样的,都是用来改变方法的this关键字,并且把方法执行;而且在严格模式下
    // 和非严格模式下,对于第一个参数时null/undefined也是一样的
    fn.call(obj);
    fn.apply(obj, [100, 200]); // -> call在给fn传递的时候,是一个一个传递值的, 而apply不是一个个的传,而是
    // 把要把fn传递的参数值统一的放在一个数组中进行操作 -> 但是也相当于一个个的给fn的形参赋值

    // bind: 这个方法在IE6-8下不兼容 -> 和call/apply类似,都是用来改变this关键字的
//    fn.call(obj, 100, 200); -> 改变this和执行fn函数一起都完成的
    // -> 预处理: 事先把fn的this改变为我们想要的结果,并且把对应的参数值也准备好,以后要用到了,直接的执行即可
    var tempFn = fn.bind(obj, 100, 200); // -> 只是改变fn中的this为obj,并且给fn传递了两个参数值100,200, 但是此时并没有
    // 把fn这个函数执行; 执行bind会有一个返回值,这个返回值tempFn就是我们把fn的this改变后的那个结果
    tempFn();
</script>
</body>
</html>