<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    function CreateJsPerson(name, age) {
        var obj = {};
        obj.name = name;
        obj.age = age;
        obj.writeJs = function () {
            console.log('my name is ' + this.name + ', age is ' + this.age);
        }
        return obj;
    }
    var p1 = CreateJsPerson('zhangsan', 48);
    p1.writeJs();
    var p2 = CreateJsPerson('lisi', 20);
    p2.writeJs();

    // **构造函数模式**的目的就是为了创建一个自定义类,并且创建这个类的实例
    // 构造函数模式和工厂函数模式的区别:
    // 1. 执行的时候
    // 普通函数执行 -> createJsPerson()
    // 构造函数模式 -> new CreateJsPerson()，通过new执行后，我们的createJsPerson就是一个类了
    // 而函数执行的返回值(p1)就是CreateJsPerson的一个实例

    // 创建一个数组:
    var ary = []; // 字面量方式
    var ary = new Array(); // 实例创建方式 -> 构造函数模式执行的方式
    // 不管哪一种方式，ary都是Array这个类的一个实例

    // JavaScript中，所有的类都是函数数据类型的，它通过new执行，变成了一个类，但是它本身也是一个普通的函数
    // JavaScript中，所有的实例都是对象数据类型的

    // 2. 在函数代码执行的时候
    // 相同点：都是形成一个私有的作用域，然后经历了 形参赋值 -> 预解释 -> 代码从上到下执行。（类和普通函数一样，它也有普通函数的一面）
    // 不同点：在代码执行之前，不用自己再手动的创建obj对象了，浏览器会默认的创建一个对象数据类型值(这个对象其实就是当前类的一个实例)
    // 接下来代码从上到下执行，以当前实例为执行的主体，this代表的就是当前的实例，然后分别的把属性名和属性值赋值给当前的实例
    function CreateJsPerson(name, age) {
        this.name = name;
        this.age = age;
    }
</script>
</body>
</html>